pub mod warn;
pub mod err;

use warn::CompilerWarning;
use err::CompilerError;

use super::scan::location::Location;

#[derive(Debug)]
/// # CompilerDiagnostic
/// Either a `Warning` or an `Error`.
// TODO: Info/Notes?
pub enum CompilerDiagnostic {
    Warning(CompilerWarning),
    Error(CompilerError),
    // Note(CompilerNote) //??
}

#[derive(Debug)]
/// # Diagnostic
/// A Struct containing a `CompilerDiagnostic` and a location.
/// It represents any error or warning generated by the compiler
/// at a location in code.
/// 
/// For example: an error of type `UNEXPECTED_EOF` on line 4,
/// column 12 can be represented like this:
/// ```rust
/// Diagnostic {
///     diagnostic: CompilerDiagnostic::Error(
///         CompilerError::UNEXPECTED_EOF
///     ),
///     location: Location {
///         position: 12,
///         line: 4
///     }
/// }
/// ```
/// 
/// For more info see the `CompilerDiagnostic` enum.
pub struct Diagnostic {
    pub diagnostic: CompilerDiagnostic,
    pub location: Location,
}

impl Diagnostic {
    pub fn new(diag: CompilerDiagnostic, location: Location) -> Diagnostic {
        return Diagnostic { diagnostic: diag, location};
    }
}

/// # Diagnostics
/// A Vector of `Diagnostic`.
/// 
/// See the `Diagnostic` struct for more info
pub type Diagnostics = Vec<Diagnostic>;

/// # Status
/// Useful type for use in recursive functions to
/// propagate **ONE** Error at a time.
pub type Status = Option<CompilerDiagnostic>;

macro_rules! ok {
    () => {
        None
    };
}

macro_rules! warning {
    ($warning:expr) => {
        Some(CompilerDiagnostic::Warning($warning))
    };

    ($warning:ident) => {
        Some(CompilerDiagnostic::Warning(crate::warn::CompilerWarning::$warning))
    }
}

macro_rules! error {
    ($error:expr) => {
        Some(CompilerDiagnostic::Error($error))
    };

    ($error:ident) => {
        Some(CompilerDiagnostic::Error(crate::warn::CompilerError::$error))
    }
}

pub(crate) use ok;
pub(crate) use warning;
pub(crate) use error;